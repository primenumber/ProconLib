\section{Graph}

\subsection{最短経路}
上から順に，ダイクストラ，経路復元付きダイクストラ，ベルマンフォード，ワーシャルフロイド，辺のコストが0か1のときのみ使える幅優先探索である．
\lstinputlisting{../Graph/ShortestPath.cpp}

\subsection{最小全域木}
クラスカルを用いるときは，比較演算子をの大小関係を変える必要がある．また，頂点数をNに入れておくこと．
\lstinputlisting{../Graph/MinimumSpanningTree.cpp}

\subsection{最大流}
Ford-Fulkerson
\lstinputlisting{../Graph/FordFulkerson.cpp}
Dinic
\lstinputlisting{../Graph/Dinic.cpp}

\subsection{最小費用流}
\lstinputlisting{../Graph/MinCostFlow.cpp}

\subsection{二部グラフの最大マッチング}
\lstinputlisting{../Graph/BipartiteMatching.cpp}
\lstinputlisting{../Graph/HopcroftKarp.cpp}

\subsection{ハンガリアン法}
\begin{itemize}
  \item 二部正則グラフ$$K_{n,n}$$の最大重みマッチングを求める
  \item \verb#m[i][j]#で左側頂点iと右側頂点jの間のコストを与える
  \item x: 左側頂点に対応する右側頂点, y: 右側頂点に対応する左側頂点
  \item 返り値は最大重みマッチングの重みの合計
\end{itemize}
\lstinputlisting{../Graph/Hungarian.cpp}

\subsection{強連結成分分解}
\begin{itemize}
  \item \verb#vector<int> g[], rg[]# : グラフと逆辺のグラフ．\verb#add_edge#関数で作る
  \item cmp[] : DAGのトポロジカル順序．srcから順に番号が付けられる．
  \item scc(int) : グラフの頂点数を引数にとり，強連結成分分解を行う．返り値はDAGの頂点数．
  \item グラフの頂点数とDAGの頂点数を引数にとり，DAGを生成する．頂点番号はcmpと同じ．
\end{itemize}
\lstinputlisting{../Graph/StronglyConnectedComponents.cpp}

\subsection{2-SAT}
\lstinputlisting{../Graph/2SAT.cpp}

\subsection{最小共通祖先}
二分探索バージョン
\lstinputlisting{../Graph/LCA(BinarySearch).cpp}
RMQバージョン
\lstinputlisting{../Graph/LCA(RMQ).cpp}
データ構造バージョン
\lstinputlisting{../Graph/LCA(Structure).cpp}

\subsection{重軽分解}
\lstinputlisting{../Graph/HLD.cpp}

\subsection{最短ハミルトン路}
\lstinputlisting{../Graph/ShortestHamiltonPath.cpp}

\subsection{彩色数}
\lstinputlisting{../Graph/ChromaticNumber.cpp}

\subsection{間接点}
\lstinputlisting{../Graph/ArticulationPoints.cpp}

\subsection{橋}
\lstinputlisting{../Graph/Bridge.cpp}

\subsection{オイラー路}
\lstinputlisting{../Graph/EulerPath.cpp}

\subsection{最大独立集合}
\lstinputlisting{../Graph/MaximumIndependentSet.cpp}

\subsection{最小全域有向木}
\lstinputlisting{../Graph/MinimumArborescence.cpp}

\subsection{一般グラフの最小カット}
\lstinputlisting{../Graph/GlobalMinimumCut.cpp}

\subsection{ZDD}
\lstinputlisting{../Graph/ZDD.cpp}
